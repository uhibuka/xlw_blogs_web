---
title: Java Basice
icon: fab fa-markdown
order: 2
category:
  - 使用指南
tag:
  - Markdown
---

::: details 1.基本类型和包装类型的区别？

**相同点** ：都可以用作变量，无论是方法传递的参数还是成员变量。

**不同点** ：一个是基础数据类型，一个是引用数据类型

- 两者在比较的时候方式不同；
- 储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）；
- 所占空间大小不同；
- 初始化的默认值也不同；

包装类的自动拆装箱：从字节码中，我们发现装箱其实就是调用了包装类的`valueof()`方法，拆箱其实就是调用了 `xxxValue()`方法。

:::

::: details 2.包装类的缓存机制

- Integer： -128~127（包括Long，Short，Byte）
- Boolean： true/false
- Character： 0~127
- 两种浮点数类型的包装类`Float`，`Double`并没有实现缓存机制。

:::

::: details 3.成员变量和局部变量的区别？

- **位置区别** ：成员变量在类里面与方法同级；局部变量在方法内部

> 成员变量可以被`public`，`private`，`static`等修饰符修饰，而局部变量不能被访问控制修饰符，以及static等修饰符所修饰，但是成员变量和局部变量都能够被`final`修饰

- **存储方式**：从变量在内存中的存储方式来看，如果成员变量使用`static`修饰，那么这个成员变量属于类，位于方法区，如果没有，那么这个变量就是属于实例的，存放在堆内存。局部变量则存在于栈内存的局部变量表。
- **默认值**：成员变量如果没有被赋初始值，就会以类型的默认值而赋值（被final修饰的的成员变量必须显式的地赋值），而局部变量不会自动赋值。
- **生存时间**：成员变量是对象地一部分，随着对象地创建而存在，而局部变量是随着方法地调用而自动生成，随着方法调用结束而消亡。

:::

::: details  4.静态变量有什么作用？

`static`的主要作用是使成员变量或方法与类关联，而不是与类的实例关联

- 这意味着他们可以在没有创建类实力的情况下被访问和调用。同时，静态成员变量也可以被所有该类的实例共享，可以用于存储类级别的信息，比如计数器，常量等。
- 静态变量只会被分配一次内存，即使创建多个对象，他们都共享一份静态变量，这样可以节省内存。
- 可以通过类名访问，可以搭配`final`关键字做常量。
:::

::: details  5.字符型常量和字符串常量的区别？

- 形式：字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符。

- 含义：字符常量相当于一个整型值（ASCII 值），可以参加表达式运算；字符常量代表一个地址值（该字符串在内存中存放位置）。

- 占内存大小：字符常量只占两个字节；字符串常量占若干个字节。

  **注意 `char`在Java中占两个字节**

::: details  6.静态方法为什么不能调用非静态成员？

需结合JVM相关知识，主要原因如下：

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员变量，属于非法操作。
:::

::: details  7.静态方法和实例方法有何不同？

1. 形式：静态方法-static修饰，是属于类的，每个类就一份，在类加载的时候会分配内存，可以通过类名直接访问，实例方法需要创建对应的实例对象才能调用，多个实例对象都有各自的实例方法。
2. 调用方式：静态方法-类名点进行调用，实例方法需要创建实例对象，然后实例对象点进行调用。
3. 访问限制的区别：静态只能调用静态，实例都可以调用。
4. 生命周期：静态方法的生命周期和类相关，而实例方法与对应实例相关。
:::

::: details 8.重载和重写的区别？

共同点：

1. 都涉及方法：可以在类中定义多个方法，他们的方法名相同但是参数列表不同。
2. 都是多态的体现：多态是指同一个方法名可以在同一个类的不同方法或者不同的类中以不同的方式实现。

- 重载一个类可以有多个同名方法。
- 重写就是子类对父类方法重新改造，外部样子不能改变，内部逻辑可以改变。

不同点：

1. 适用范围不同：
   - 重载（Overloading）指的是在同一个类中定义多个方法，他们的方法名相同，但是参数列表不同。
   - 重写（Overriding）指的是子类可以定义与父类中同名、同参数列表的方法，用于覆盖父类中的方法，重写只发生在子类覆盖父类的方法情况。
2. 方法签名：
   - 对于重载，方法名相同但是参数列表必须不同（参数类型，顺序，个数）
   - 对于重写，方法名、参数列表必须相同，返回类型可以是子类的类型或者其子类型。
3. 返回类型
   - 对于重载，返回类型可以相同也可以不同，但是方法的参数列表必须不同。
   - 对于重写，返回类型必须相同或是其子类
4. 运行时行为
   - 对于重载，方法调用的解析在编译时发生，根据传入的参数类型来决定调用哪个方法。
   - 对于重写，方法的调用在运行时通过动态分派发生，根据实际对象的类型来决定调用哪个方法。
:::

::: details 9.面向对象和面向过程的区别？

- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法执行解决问题
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题
- 面向对象由于封装、继承、多态三大特征的原因，更易维护、易复用。但是因其要实例化对象，对性能的开销比较大。
:::

::: details 10.面向对象三大特征

**封装、继承、多态**：

- 封装：把成员变量和具体的方法封装到一个具体的类中，以后的编码无需关系对象内部问题，只面对这个对象本身。
- 继承：核心目的就是代码复用，通过继承，子类可以复用父类的方法，并可以通过super关键字直接调用，也能重写父类的方法，形成多态。可以通过组合的方式，降低耦合，实现更好的封装
- 多态：表示一个对象具有多种状态。（有继承（接口、抽象类、类）、有重写、父类引用指向子类对象）。

::: details 11.接口和抽象类的区别？

共同点：

- 接口和抽象类都不能被实例化。
- 接口和抽象类都可以包含抽象方法，没有方法体的方法。
- 接口和抽象类都可以由默认实现的方法

不同点：

- 抽象类是一个类使用 abstract class，并且抽象方法需要使用abstract修饰，而接口使用interface修饰，接口的抽象方法默认就是抽象，不需要添加abstract。
- 抽象类可以继承一个类，也可以实现一个接口，但是只能继承一个，但是能够实现多个。而接口只能继承，但是可以继承多个。
- 抽象类可以有构造器，而接口没有。
- 接口主要是用以对类的行为进行约束，实现了某个接口，就具有了对应的行为。抽象类主要用于代码复用，强调的数所属关系。
:::

::: details 12.深拷贝和浅拷贝的区别是什么？什么是引用拷贝？

- 深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象，得到的是一个全新的对象。
- 浅拷贝：浅拷贝会在堆上创建一个新的对象，只拷贝当前对象，如果当前对象的内部是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也即是说拷贝对象和原对象共用一个内部对象。
- 引用拷贝：简单来说，引用拷贝就是两个不同的引用指向同一个对象
:::

::: details 13.Object类的常见方法有哪些？

11个常用方法：

``` java
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * native 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }

```

:::

::: details 14.==和equals()的区别？

- ==：==在比较基本数据类型时，比较的是值，比较引用数据类型时比较的时内存地址
- equals()：在本质上和==相同，但是equals()可以被重写，重写之后会通过其他内容进行比较。例如，String重写了equals()之后会通过字符值进行比较，另外重写equals之后必须重写hashcode()。
::: 

::: details 15.什么是hashcode()？

1. `hashCode()` 是 Java 中 `Object` 类的一个方法，用于返回对象的哈希码值。哈希码是一个整数，它代表了对象在内存中的地址或者说是对象的标识符。每个对象都有一个唯一的哈希码，即使它们的内容相同，哈希码也会不同。

2. `hashCode()` 方法的存在是为了支持基于哈希表的数据结构，例如 `HashMap` 或 `HashSet`。这些数据结构在查找、插入等操作时依赖于哈希码来确定对象的存储位置，从而提高了操作的效率，而且先检验`hashCode`，这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

3. 虽然 `hashCode()` 方法对于基于哈希表的数据结构非常重要，但它仅仅是一个计算哈希码的方法，不提供确切的对象比较。实际上，在哈希表中，可能会出现不同对象具有相同哈希码的情况，这称为哈希冲突。因此，还需要提供 `equals()` 方法来确切地比较两个对象是否相等。

4. 两个对象具有相同的 `hashCode` 值，这意味着它们在哈希表中可能会被放置到相同的位置。然而，哈希码只是一个指示，它并不一定能够唯一地标识一个对象。因此，即使两个对象的哈希码相同，它们的内容也可能是不同的，这种情况称为哈希码冲突。 

   - 因为`hashCode()`可以重写，假如我们有一个学生类，有两个属性id和name，我们重写`hashCode`，把id当`hashCode`，他们id全是1，但是姓名却不同，这样虽然`hashCode`相等，但是`equals`却不相等。

   - 总的来说，`hashCode()` 提供了一种快速确定对象存储位置的方法，但它并不能保证对象的唯一性。因此，仍然需要使用 `equals()` 方法来确切地比较两个对象是否相等。
::: 

::: details 16.为什么重写equals()时必须重写hashcode()方法？

1. `equals()`和`hashcode()`分别用于不同的目的：
   - `equals()`用于确切的比较两个对象的内容是否相等。
   - `hashCode()`用于在哈希表等数据结构中确定对象的存储位置，以提高从查找和插入的效率。
2. 重写 `equals()` 方法时，必须同时重写 `hashCode()` 方法的原因是：
   - hashCode()和equals() 在哈希表等数据结构中配套使用的。在使用哈希表时，首先会根据对象的hashCode()值确定存储位置，然后再使用equals()方法来确切的比较对象是否相等。
   - 如果两个对象在equals() 方法中被认为相等，那么他们的hashCode()值也必须相等，以确保他们在哈希表中的存储位置一直，否则会导致对象在哈希表中无法被正确检索。

总的来说重写 `equals()` 方法时，也要重写 `hashCode()` 方法，以保证对象在哈希表等数据结构中的正确性和性能。
::: 

::: details 17.重写`equals()`时没有重写`hashCode()`方法的话，使用`HashMap`可能会出现什么问题？

1. `hashCode()`相等但是`eques()`不相等。
   - 这会导致两个对象被放到相同的位置，但由于`equals()`返回`false`，它们被认为不相等。这会导致在查找时无法正确的找到相等的对象。
2. `hashCode()`不相等但是`eques()`相等。
   - 会导致两个对象在哈希表中被放到相同的位置，由于equals()返回`false`，它们被认为不相等，这会导致在查找时无法正确的找到相等的对象。

这两种情况都破坏了哈希表的正确性和性能。

1. 哈希冲突：由于没有重写`hashCode()`方法，对象的哈希码将由默认的Object类的实现决定，这可能导致相同内容的对象具有不同的哈希码，从而产生哈希冲突。这回影响到对象在哈希表中的存储位置。
2. 无法正确的检索对象
3. 无法正确的删除对象
4. 导致内存泄漏
::: 

::: details 18.String、StringBuffer、StringBuilder 的区别

- String是不可变的，因为被final修饰了，不能被继承，同时String内部维护了一个private final修饰的char数组，但是没有提供修改这个字符串的方法，因此是线程安全的。对任何String的操作都会返回一个新的String对象。
- StringBuffer、StringBuilder 都是继承自`AbstractStringBuilder`，内部维护的是char数组，是可变的，但是`StringBuffer`的所有方法都是synchronized修饰的同步方法，每次只能一个线程访问，是线程安全的，但是`StringBuilder` 不是线程安全的，不适合在多线程环境使用。

Java9把String的底层实现由char[]改成了byte[],支持两个编码方案：Latin-1 和 UTF-16（Java8之前只支持UTF-6）。如果字符串的汉字没有超过Latin-1 的范围就会使用Latin-1 。Latin-1 编码下byte只占一个字节，相较于char节省了空间。
::: 

::: details 19.字符串拼接用”+“还是StringBuilder？

本质都是StringBuilder的append()方法拼接，但是用"+"的话编译器不会创建单个StringBuilder复用，会导致创建过多的StringBuilder对象。
::: 

::: details 20.String s1 = new String("abc");这句话创建了几个字符串对象？String.intern() 方法有什么作用?

会创建1或2个

1. 如果字符串常量池中不存在字符串对象”abc“的引用，那么他将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共2个字符串对象。
2. `String.intern()`是一个native（本地）方法，其作用是将指定的字符串对象引用保存在字符串常量池中，可以分为两种情况：
   - 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
   - 如果字符串常量池没有保存对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。
::: 

::: details 21.String类型的变量和常量做+运算时发生了什么

- 常量和常量：**对于编译期可以确定值的字符串，也就是常量字符串，jvm会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放到字符串常量池，这得益于编译器的优化-常量折叠**
- 常量和变量，变量和变量：**引用的值在编译期是无法确定的，编译器无法对其进行优化**
  - 对象引用和”+“的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。
::: 

::: details 22.Java的异常体系介绍一下

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为：

  - Checked Exception (受检查异常，必须处理) - 编译时异常

    - **IOException** 及其子类：
      - `FileNotFoundException`
      - `IOException`
      - `EOFException` 等
    - **SQLException**：与数据库操作相关的异常。
    - **ClassNotFoundException**：当试图加载类但找不到对应的类文件时抛出。
    - **InterruptedException**：当一个线程处于阻塞、等待或睡眠状态，但被另一个线程中断时抛出。
    - **CloneNotSupportedException**：当试图克隆一个不支持克隆的对象时抛出。
    - **NoSuchMethodException**：当试图调用一个不存在的方法时抛出。
    - **NoSuchFieldException**：当试图访问一个不存在的字段时抛出。
    - **InstantiationException** 和 **IllegalAccessException**：通常与反射相关，当试图实例化一个抽象类、接口或私有构造函数时抛出。
    - **ParseException**：通常与日期解析相关，当无法解析字符串为指定格式的日期时抛出。
    - **MalformedURLException**：当试图创建一个URL实例，但提供的URL格式不正确时抛出。

  - Unchecked Exception (不受检查异常，可以不处理) - 运行时异常

    - `RuntimeException` 及其子类都统称为非受检查异常

    - `ArithmeticException`（算术错误）

    - `NullPointerException`(空指针错误)

    - `ClassCastException`（类型转换错误）

    - `ArrayIndexOutOfBoundsException`（数组越界错误）

    - `IllegalArgumentException`(参数错误比如方法入参类型错误)

    - `NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException`的子类）

    - `SecurityException` （安全错误比如权限不够）

      `UnsupportedOperationException`(不支持的操作错误比如重复创建同一用户)

- **`Error`**：`Error` 属于程序无法处理的错误 ，我们没办法通过 `catch` 来进行捕获不建议通过`catch`捕获 。例如 Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

  - **OutOfMemoryError**：当JVM耗尽了可用的内存资源时抛出，导致无法继续执行程序。
  - **StackOverflowError**：当一个线程递归调用的深度超过了JVM所能处理的范围时抛出，通常是因为调用栈溢出。
  - **NoClassDefFoundError**：当试图加载类，但在运行时找不到类的定义时抛出。
  - **ExceptionInInitializerError**：当一个类的静态初始化器（静态代码块）抛出异常时抛出，导致类无法被正确初始化。
  - **LinkageError**：代表在链接阶段出现问题，通常是由于类版本不匹配、缺少依赖项等情况。
  - **VirtualMachineError**：是所有错误的父类，用于表示与虚拟机操作有关的错误情况。
  - **AssertionError**：通常由 `assert` 语句失败抛出，用于在测试代码中检查条件是否为真。
  - **InternalError**：表示Java虚拟机发现了内部错误或不一致性。

  请注意，与编译时异常和运行时异常不同，`Error` 不是必须被捕获或抛出的，因为它们通常表示程序无法恢复的严重问题。通常情况下，最好的做法是让程序终止并记录错误信息以便调查。

1. 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。
2. 建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出`NumberFormatException`而不是其父类`IllegalArgumentException`。
3. 抛出 / 打印的异常信息一定要有意义。
4. 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。
::: 

::: details 23.Throwable有哪些常用方法？

`void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息

`String getMessage()`: 返回异常发生时的简要描述

`String toString()`: 返回异常发生时的详细信息

`String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
::: 

::: details 24.try-catch-finally使用介绍一下

- try块用于捕获异常，其后面可以接0个或多个catch块，如果没有catch块必须有finally块。
- catch块用于处理try'捕获到的异常
- finally块：无论是否捕获到异常，finally块里的代码都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

**注意：不要在finally块中使用return！**

- 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略，但是会执行 try 语句的return代码
::: 

::: details 25.finally中的代码一定会执行吗？

1. finally之前程序所在的线程死亡
2. finally之前虚拟机被终止运行的话不会。——System.exit(1);
3. finally之前关闭CPU。
::: 

::: details 26.什么是泛型

泛型就是一种能够让程序处理各种不同类型的数据的方法。

- 他就像一个容器，可以装不同类型的东西，但是在使用的时候，你可以告诉它具体装的是什么类型的东西，这样程序能够更加灵活和安全的处理数据。

泛型（Generics）是一种在编程中提供强大类型安全性的特性。它允许你在代码中定义类、接口、方法等时使用一个或多个类型参数，从而实现对类型的参数化。这样可以在编译时期提供更强的类型检查，并减少了在运行时出现类型错误的可能性。

泛型的作用：

1. 类型安全性：泛型可以在编译时期检查代码，防止类型不匹配的错误。这使得代码更加健壮和可靠。
2. 代码复用：泛型代码可以适用于多种数据类型，减少了重复编写相似代码的工作量。
3. 抽象数据类型：泛型可以用于定义通用的数据结构和算法，如列表、栈、队列等。
4. 库的通用性：泛型使得库能够提供通用的数据结构和算法，可以被不同的数据类型使用。
:::    

::: details 27.什么是反射？

反射（Reflection）是一种在运行时动态获取类信息、调用对象方法、访问对象属性的能力。

- 反射允许程序在运行时获取类的信息，比如类名、方法名、属性等，并且可以在运行时调用这些方法，访问这些属性。这样可以是程序在运行时动态的进行操作，而不需要在编译时就确定号所有的类和方法。
::: 

::: details 28.反射的原理是什么？

反射的原理是依赖于底层虚拟机的机制和在运行时通过反射API（java.lang.reflect包）来操作程序的元信息（如类、方法、属性）

- 在Java中，虚拟机会在加载类的时候生成相应的`Class`对象，这个对象包含了类的所有信息。反射API就是在这个基础上提供了一系列的方法来访问和操作这些信息。
- 在运行时可以通过反射机制-反射API来获取和操作

在底层，实现反射通常涉及以下几个步骤：

1. **获取类信息**: 首先，程序通过类加载器加载一个类，并在内存中创建一个表示该类的`Class`对象。这个`Class`对象包含了该类的所有信息，如方法、属性等。
2. **获取成员信息**: 通过`Class`对象可以获取到类的所有成员（字段和方法），包括公共的、私有的等。
3. **访问成员**: 反射API提供了方法来访问类的成员，比如获取和设置属性的值，调用方法等。这可以绕过编译时的访问权限检查。
4. **创建对象实例**: 反射可以通过`Class`对象来创建类的实例。
5. **调用方法**: 反射可以动态地调用类的方法，包括公共的、私有的等。

需要注意的是，由于**反射的操作是在运行时进行的，相比直接调用代码，反射会带来一定的性能损耗**。因此，在性能要求高的场景下，应该避免过度使用反射。
::: 

::: details 29.反射的应用场景有哪些？

1. 动态代理：反射可以用于创建动态代理，显示在运行时动态生成代理类，对原有类进行增强。如动态代理设计模式。
2. 动态加载类：可以在程序运行时动态加载一些类。例如插件系统，或者根据配置文件动态加载不同的实现。
3. 框架和库开发：很多框架和库使用反射来实现各种功能。（例如Spring中的依赖注入，AOP等）。
4. 配置文件处理：可以通过反射来读取配置文件中的类名、方法名等信息，从而动态的创建对象或调用方法。

总的来说，反射是一种非常强大的机制，可以让程序在运行时获取并操作类的信息，从而实现许多灵活和高级的功能。然而，由于反射的运行时性能开销相对较高，因此在使用时需要慎重考虑性能方面的影响。
::: 




