"use strict";(self.webpackChunkblogs_web=self.webpackChunkblogs_web||[]).push([[518],{7708:(t,e)=>{e.A=(t,e)=>{const a=t.__vccOpts||t;for(const[t,o]of e)a[t]=o;return a}},967:(t,e,a)=>{a.r(e),a.d(e,{comp:()=>l,data:()=>n});var o=a(4754);const i=[(0,o.Fv)('<details class="hint-container details"><summary>1.基本类型和包装类型的区别？</summary><p><strong>相同点</strong> ：都可以用作变量，无论是方法传递的参数还是成员变量。</p><p><strong>不同点</strong> ：一个是基础数据类型，一个是引用数据类型</p><ul><li>两者在比较的时候方式不同；</li><li>储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）；</li><li>所占空间大小不同；</li><li>初始化的默认值也不同；</li></ul><p>包装类的自动拆装箱：从字节码中，我们发现装箱其实就是调用了包装类的<code>valueof()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p></details><details class="hint-container details"><summary>2.包装类的缓存机制</summary><ul><li>Integer： -128~127（包括Long，Short，Byte）</li><li>Boolean： true/false</li><li>Character： 0~127</li><li>两种浮点数类型的包装类<code>Float</code>，<code>Double</code>并没有实现缓存机制。</li></ul></details><details class="hint-container details"><summary>3.成员变量和局部变量的区别？</summary><ul><li><strong>位置区别</strong> ：成员变量在类里面与方法同级；局部变量在方法内部</li></ul><blockquote><p>成员变量可以被<code>public</code>，<code>private</code>，<code>static</code>等修饰符修饰，而局部变量不能被访问控制修饰符，以及static等修饰符所修饰，但是成员变量和局部变量都能够被<code>final</code>修饰</p></blockquote><ul><li><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量使用<code>static</code>修饰，那么这个成员变量属于类，位于方法区，如果没有，那么这个变量就是属于实例的，存放在堆内存。局部变量则存在于栈内存的局部变量表。</li><li><strong>默认值</strong>：成员变量如果没有被赋初始值，就会以类型的默认值而赋值（被final修饰的的成员变量必须显式的地赋值），而局部变量不会自动赋值。</li><li><strong>生存时间</strong>：成员变量是对象地一部分，随着对象地创建而存在，而局部变量是随着方法地调用而自动生成，随着方法调用结束而消亡。</li></ul></details>',3)],r={},l=(0,a(7708).A)(r,[["render",function(t,e){return(0,o.uX)(),(0,o.CE)("div",null,i)}]]),n=JSON.parse('{"path":"/guide/Java/set.html","title":"Java Set","lang":"en-US","frontmatter":{"title":"Java Set","icon":"fab fa-markdown","order":2,"category":["使用指南"],"tag":["Markdown"],"description":"1.基本类型和包装类型的区别？ 相同点 ：都可以用作变量，无论是方法传递的参数还是成员变量。 不同点 ：一个是基础数据类型，一个是引用数据类型 两者在比较的时候方式不同； 储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）； 所...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/guide/Java/set.html"}],["meta",{"property":"og:site_name","content":"Knowledge is infinite."}],["meta",{"property":"og:title","content":"Java Set"}],["meta",{"property":"og:description","content":"1.基本类型和包装类型的区别？ 相同点 ：都可以用作变量，无论是方法传递的参数还是成员变量。 不同点 ：一个是基础数据类型，一个是引用数据类型 两者在比较的时候方式不同； 储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）； 所..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-03-29T07:25:57.000Z"}],["meta",{"property":"article:author","content":"RenTouZhuNao"}],["meta",{"property":"article:tag","content":"Markdown"}],["meta",{"property":"article:modified_time","content":"2024-03-29T07:25:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java Set\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-29T07:25:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"RenTouZhuNao\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1711697157000,"updatedTime":1711697157000,"contributors":[{"name":"uhibuka","email":"2580874889@qq.com","commits":1}]},"readingTime":{"minutes":1.85,"words":556},"filePathRelative":"guide/Java/set.md","localizedDate":"March 29, 2024","autoDesc":true}')},6940:(t,e,a)=>{a.r(e),a.d(e,{comp:()=>l,data:()=>n});var o=a(4754);const i=[(0,o.Fv)('<details class="hint-container details"><summary>1.基本类型和包装类型的区别？</summary><p><strong>相同点</strong> ：都可以用作变量，无论是方法传递的参数还是成员变量。</p><p><strong>不同点</strong> ：一个是基础数据类型，一个是引用数据类型</p><ul><li>两者在比较的时候方式不同；</li><li>储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）；</li><li>所占空间大小不同；</li><li>初始化的默认值也不同；</li></ul><p>包装类的自动拆装箱：从字节码中，我们发现装箱其实就是调用了包装类的<code>valueof()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p></details><details class="hint-container details"><summary>2.包装类的缓存机制</summary><ul><li>Integer： -128~127（包括Long，Short，Byte）</li><li>Boolean： true/false</li><li>Character： 0~127</li><li>两种浮点数类型的包装类<code>Float</code>，<code>Double</code>并没有实现缓存机制。</li></ul></details><details class="hint-container details"><summary>3.成员变量和局部变量的区别？</summary><ul><li><strong>位置区别</strong> ：成员变量在类里面与方法同级；局部变量在方法内部</li></ul><blockquote><p>成员变量可以被<code>public</code>，<code>private</code>，<code>static</code>等修饰符修饰，而局部变量不能被访问控制修饰符，以及static等修饰符所修饰，但是成员变量和局部变量都能够被<code>final</code>修饰</p></blockquote><ul><li><strong>存储方式</strong>：从变量在内存中的存储方式来看，如果成员变量使用<code>static</code>修饰，那么这个成员变量属于类，位于方法区，如果没有，那么这个变量就是属于实例的，存放在堆内存。局部变量则存在于栈内存的局部变量表。</li><li><strong>默认值</strong>：成员变量如果没有被赋初始值，就会以类型的默认值而赋值（被final修饰的的成员变量必须显式的地赋值），而局部变量不会自动赋值。</li><li><strong>生存时间</strong>：成员变量是对象地一部分，随着对象地创建而存在，而局部变量是随着方法地调用而自动生成，随着方法调用结束而消亡。</li></ul></details>',3)],r={},l=(0,a(7708).A)(r,[["render",function(t,e){return(0,o.uX)(),(0,o.CE)("div",null,i)}]]),n=JSON.parse('{"path":"/zh/guide/java/set.html","title":"Java集合","lang":"zh-CN","frontmatter":{"title":"Java集合","icon":"fab fa-markdown","order":2,"category":["使用指南"],"tag":["Markdown"],"description":"1.基本类型和包装类型的区别？ 相同点 ：都可以用作变量，无论是方法传递的参数还是成员变量。 不同点 ：一个是基础数据类型，一个是引用数据类型 两者在比较的时候方式不同； 储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）； 所...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/zh/guide/java/set.html"}],["meta",{"property":"og:site_name","content":"学无止境"}],["meta",{"property":"og:title","content":"Java集合"}],["meta",{"property":"og:description","content":"1.基本类型和包装类型的区别？ 相同点 ：都可以用作变量，无论是方法传递的参数还是成员变量。 不同点 ：一个是基础数据类型，一个是引用数据类型 两者在比较的时候方式不同； 储存方式不同，基本类型一般作为参数和代码块内的局部变量（栈的局部变量表中），如果是成员变量（队），static修饰的（方法区）。引用数据类型（堆），static修饰的（方法区）； 所..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-29T07:25:57.000Z"}],["meta",{"property":"article:author","content":"RenTouZhuNao"}],["meta",{"property":"article:tag","content":"Markdown"}],["meta",{"property":"article:modified_time","content":"2024-03-29T07:25:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java集合\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-29T07:25:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"RenTouZhuNao\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":1711697157000,"updatedTime":1711697157000,"contributors":[{"name":"uhibuka","email":"2580874889@qq.com","commits":1}]},"readingTime":{"minutes":1.86,"words":557},"filePathRelative":"zh/guide/java/set.md","localizedDate":"2024年3月29日","autoDesc":true}')}}]);